package gameElements;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import tools.Circle;
import tools.GraphicTools;
import tools.Vector2D;
import interfaces.Collidable;
import interfaces.Drawable;
/**
 * This class represents a drawable and collidable line
 * 
 * @author Arkasha
 *
 */
public class GraphicLine2D implements Drawable, Collidable{
	
	/**
	 * this is the shape of the object
	 */
	private Line2D line;
	
	/**
	 * this is a line used in tests
	 */
	private Line2D testline;
	
	/**
	 * this is the color of the object
	 */
	private Color color;
	
	/**
	 * this is a compass used in calculations
	 */
	private Circle compass;
	
	public GraphicLine2D(Line2D line,Color color){
		this.line=line;
		this.color=color;
	}
	
	public GraphicLine2D(Point2D p1,Point2D p2,Color color){
		this(new Line2D.Double(p1,p2),color);
	}
	
	public GraphicLine2D(Line2D line){
		this(line,Color.WHITE);
	}

	public GraphicLine2D(Point2D p1,Point2D p2){
		this(new Line2D.Double(p1,p2),Color.WHITE);
	}
	
	/**
	 * Draws the line - Drawable Interface method
	 */
	public void draw(Graphics2D g2D) {
		g2D.setColor(this.color);
		g2D.draw(this.line);
		if(testline!=null)
			g2D.draw(this.testline);
		if(compass!=null)
			g2D.draw(this.compass);
	}

	/**
	 * Tests if a circle collides with this object
	 */
	public boolean CollisionTest(Circle c) {
		double distance = line.ptSegDist(c.getCenter());
		double radius = c.getRadius();

		// if distance in between the center of the ball and the line is
		// shorter than the radius then collision
		if (distance < radius) {
			return true;
		}
		return false;
	}

	/**
	 *  Return the collision vector
	 */
	public Vector2D CollisionResult(Circle c,Vector2D v) {
		/*
		 * 		v' = v-2(v.n)n
		 */
		
		Vector2D n=Pinball.simplifyVector2D(v);
		
		double temp=Vector2D.dotProduct(v,n);
		Vector2D tmp=n.cstMultiplication(temp);
		tmp=tmp.cstMultiplication(2);
		tmp=v.addVector(tmp);
		tmp=Pinball.simplifyVector2D(tmp);
		
		
		
/*		
		Vector2D thisline =new Vector2D(Math.abs(this.line.getX1()-this.line.getX2()),Math.abs(this.line.getY1()-this.line.getY1()));
		double angle = v.vectAngle(thisline);
		
		v=v.rotation(-angle*2);
		v=Pinball.simplifyVector2D(v);
		
		System.out.println(v.getXCoord());
		System.out.println(v.getYCoord());
		System.out.println();*/
		v=v.cstMultiplication(-0.75);
		double friction=1;
		v=new Vector2D(v.getXCoord(),v.getYCoord()*friction);
		
		//System.out.println(v.getXCoord()+", "+v.getYCoord());
		//return Pinball.simplifyVector2D(v);
		return v;
		//return tmp;
	}

	/**
	 * Affect Velocity if needed
	 */
	public double AffectVelocity(double oldSpeed) {
		double friction=1;
		return oldSpeed*friction;
	}

	/**
	 *  Replace center of ball so that there is no collision problem
	 */
	public Point2D ReplaceCenter(Circle c) {
		Point2D referencePoint = c.getCenter();
		
		// Get the part of the line that is in the ball
		Line2D corde=GraphicTools.lineCircleIntersection(this.line,c);
		
		// Find the middle of this line - this is the closest point in between line and ball
		Point2D middlePoint=new Point2D.Double(Math.abs(corde.getX1()+corde.getX2())/2,Math.abs(corde.getY1()+corde.getY2())/2);
		
		// BaseLine links center and middle point - we will use compass and this line to find new middle
		Line2D baseLine=new Line2D.Double(referencePoint,middlePoint);
		//testline=baseLine;
		
		// Compass of correct length to determine new center
		Circle compass1=new Circle(c.getCenter(),c.getRadius());
		compass1.setCenter(middlePoint);
		corde=GraphicTools.lineCircleIntersection(baseLine,compass1);
		//testline=corde;
		
		// Get the point of intersection in between baseline and compass closest to existing center
		Point2D newCenter=GraphicTools.getClosestLinePoint(referencePoint,corde);
		return newCenter;
	}

}
